import kotlinx.coroutines.*
import java.io.File

data class Room(val num: Int, val type: String, var free: Boolean = true) : Comparable<Room> {
    override fun compareTo(o: Room) = num - o.num
}

interface RoomADT {
    fun add(r: Room)
    fun findFree(type: String): Room?
    fun all(): List<Room>
}

class RoomListADT : RoomADT {
    private val rooms = mutableListOf<Room>()
    override fun add(r: Room) = rooms.add(r)
    override fun findFree(type: String) = rooms.find { it.free && it.type.equals(type, true) }
    override fun all() = rooms.toList()
}

data class BookingRequest(val type: String, val name: String)

class Hotel(private val rooms: RoomADT) {
    private val bookings = mutableMapOf<Room, String>()
    val waitList = mutableListOf<BookingRequest>()

    //  Rezervare Ã®n corutinÄƒ
    suspend fun reserve(req: BookingRequest) = withContext(Dispatchers.Default) {
        rooms.findFree(req.type)?.apply {
            free = false
            bookings[this] = req.name
            println("âœ” RezervatÄƒ camera $num pentru ${req.name}")
        } != null.also {
            if (!it) {
                waitList += req
                println("âš ï¸ ${req.name} pe lista de aÈ™teptare")
            }
        }
    }

    fun show() {
        println("\nCamere:")
        rooms.all().sorted().forEach {
            println("${it.num} ${it.type} â€“ ${if (it.free) "liberÄƒ" else "ocupatÄƒ de ${bookings[it]}"}")
        }
    }

    fun save(file: String) {
        File(file).printWriter().use { w ->
            rooms.all().sorted().forEach {
                w.println("${it.num} ${it.type}: ${if (it.free) "liberÄƒ" else "ocupatÄƒ de ${bookings[it]}"}")
            }
            w.println("\nLista de aÈ™teptare:")
            waitList.forEach { w.println("${it.name} â€“ ${it.type}") }
        }
        println("ðŸ“„ Salvat Ã®n '$file'")
    }
}

// Extensie pentru procesarea listei de aÈ™teptare
fun Hotel.processWaitingList() {
    val it = waitList.iterator()
    while (it.hasNext()) runBlocking {
        val r = it.next()
        if (reserve(r)) it.remove()
    }
}

fun main() = runBlocking {
    val hotel = Hotel(RoomListADT().apply {
        add(Room(101, "Single"))
        add(Room(102, "Double"))
        add(Room(201, "Suite"))
    })

    while (true) {
        println("\n1) AratÄƒ camere   2) RezervÄƒ   3) ListÄƒ aÈ™teptare   4) ProceseazÄƒ   5) SalveazÄƒ & IeÈ™i")
        when (readLine()?.trim()) {
            "1" -> hotel.show()
            "2" -> {
                print("Nume: "); val n = readLine().orEmpty()
                print("Tip camerÄƒ: "); val t = readLine().orEmpty()
                hotel.reserve(BookingRequest(t, n))
            }
            "3" -> hotel.waitList.forEach { println("${it.name} â€“ ${it.type}") }
            "4" -> hotel.processWaitingList()
            "5" -> { hotel.save("stare.txt"); break }
            else -> println("OpÈ›iune invalidÄƒ")
        }
    }
}