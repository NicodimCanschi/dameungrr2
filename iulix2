import kotlinx.coroutines.*
import java.io.File

// 1) Obiectul CamerÄƒ
data class Camera(val nr: Int, val tip: String, var libera: Boolean = true) : Comparable<Camera> {
    override fun compareTo(other: Camera) = nr - other.nr
}

// 2) ADT pentru depozitarea camerelor
interface DepozitCamere {
    fun adauga(cam: Camera)
    fun gasesteLibera(tip: String): Camera?
    fun toate(): List<Camera>
}

class ListaCamere : DepozitCamere {
    private val camere = mutableListOf<Camera>()
    override fun adauga(cam: Camera) = camere.add(cam)
    override fun gasesteLibera(tip: String) =
        camere.find { it.tip.equals(tip, ignoreCase = true) && it.libera }
    override fun toate() = camere.toList()
}

// 3) Cererea de rezervare
data class Cerere(val tip: String, val nume: String)

// 4) Clasa Hotel cu rezervÄƒri, listÄƒ de aÅŸteptare ÅŸi salvare
class Hotel(private val depozit: DepozitCamere) {
    private val rezervari = mutableMapOf<Camera, String>()
    val listaAsteptare = mutableListOf<Cerere>()

    // rezervare Ã®n corutinÄƒ
    suspend fun rezerva(c: Cerere): Boolean = withContext(Dispatchers.Default) {
        val cam = depozit.gasesteLibera(c.tip)
        if (cam != null) {
            cam.libera = false
            rezervari[cam] = c.nume
            println("âœ” CamerÄƒ ${cam.nr} (${cam.tip}) rezervatÄƒ pentru ${c.nume}")
            true
        } else {
            listaAsteptare += c
            println("âš ï¸ Nicio camerÄƒ ${c.tip} liberÄƒ. ${c.nume} adÄƒugat Ã®n listÄƒ.")
            false
        }
    }

    // afiÈ™eazÄƒ starea camerelor
    fun afiseazaCamere() {
        println("\nCamere:")
        depozit.toate().sorted().forEach {
            val stat = if (it.libera) "liberÄƒ" else "ocupatÄƒ de ${rezervari[it]}"
            println("â€¢ ${it.nr} ${it.tip}: $stat")
        }
    }

    // salveazÄƒ starea Ã®n fiÈ™ier
    fun salveaza(numeFisier: String) {
        File(numeFisier).printWriter().use { f ->
            depozit.toate().sorted().forEach {
                val stat = if (it.libera) "liberÄƒ" else "ocupatÄƒ de ${rezervari[it]}"
                f.println("${it.nr} ${it.tip}: $stat")
            }
            f.println("\nListÄƒ de aÅŸteptare:")
            listaAsteptare.forEach { f.println("${it.nume} â€“ ${it.tip}") }
        }
        println("ğŸ“„ Stare salvatÄƒ Ã®n '$numeFisier'")
    }
}

// 5) Extensie pentru procesarea listei de aÅŸteptare
fun Hotel.processeazaLista() {
    val it = listaAsteptare.iterator()
    while (it.hasNext()) runBlocking {
        val c = it.next()
        if (rezerva(c)) it.remove()
    }
}

// 6) CLI
fun main() = runBlocking {
    val hotel = Hotel(ListaCamere().apply {
        adauga(Camera(101, "Single"))
        adauga(Camera(102, "Double"))
        adauga(Camera(201, "Suite"))
    })

    while (true) {
        println("\n1) AratÄƒ camere   2) RezervÄƒ   3) AfiÈ™eazÄƒ lista   4) ProceseazÄƒ   5) SalveazÄƒ & IeÈ™i")
        when (readLine()?.trim()) {
            "1" -> hotel.afiseazaCamere()
            "2" -> {
                print("Nume oaspete: "); val nume = readLine().orEmpty()
                print("Tip camerÄƒ: ");    val tip  = readLine().orEmpty()
                hotel.rezerva(Cerere(tip, nume))
            }
            "3" -> {
                println("\nListÄƒ de aÅŸteptare:")
                hotel.listaAsteptare.forEach { println("â€¢ ${it.nume} â€“ ${it.tip}") }
            }
            "4" -> hotel.processeazaLista()
            "5" -> { hotel.salveaza("stare_hotel.txt"); break }
            else -> println("OpÈ›iune invalidÄƒ")
        }
    }
}
